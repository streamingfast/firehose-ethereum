syntax = "proto3";

package sf.ethereum.type.v2;

option go_package = "github.com/streamingfast/firehose-ethereum/types/pb/sf/ethereum/type/v2;pbeth";

import "google/protobuf/timestamp.proto";

// Block is the representation of the tracing of a block in the Ethereum
// blockchain. A block is a collection of [TransactionTrace] that are grouped
// together and processed as an atomic unit. Each [TransactionTrace] is composed
// of a series of [Call] (a.k.a internal transactions) and there is also at
// least one call per transaction a.k.a the root call which essentially has the
// same parameters as the transaction itself (e.g. `from`, `to`, `gas`, `value`,
// etc.).
//
// The exact tracing method used to build the block must be checked against
// [DetailLevel] field. There is two levels of details available, `BASE` and
// `EXTENDED`. The `BASE` level has been extracted using archive node RPC calls
// and will contain only the block header, transaction receipts and event logs.
// Refers to the Firehose service provider to know which blocks are offered on
// each network.
//
// The `EXTENDED` level has been extracted using the Firehose tracer and all
// fields are available in this Protobuf.
//
// The Ethereum block model is used across many chains which means that it
// happen that certain fields are not available in one chain but are available
// in another. Each field should be documented when necesssary if it's available
// on a subset of chains.
//
// One major concept to get about the Block is the concept of 'ordinal'. The
// ordinal is a number that is used to globally order every element of execution
// that happened throughout the processing of the block like
// [TransactionTracer], [Call], [Log], [BalanceChange], [StateChange], etc.
// Element that have a start and end interval, [Transaction] and [Call], will
// have two ordinals: `begin_ordinal` and `end_ordinal`. Element that are
// executed as "point in time" [Log], [BalanceChange], [StateChange], etc. will
// have only one ordinal named `ordinal`. If you take all of the message in the
// Block that have an 'ordinal' field in an array and you sort each element
// against the `ordinal` field, you will get the exact order of execution of
// each element in the block.
//
// All the 'ordinal' fields in a block are globally unique for the given block,
// it is **not** a chain-wide global ordering. Furthermore, caution must be take
// with reverted elements due to execution failure. For anything attached to a
// [Call] that has a `state_reverted` field set to `true`, the `ordinal` field
// is not reliable and should not be used to order the element against other
// elements in the block as those element might have 0 as the ordinal. Only
// successful calls have a reliable `ordinal` field.
message Block {
  // Hash is the block's hash.
  bytes hash = 2;
  // Number is the block's height at which this block was mined.
  uint64 number = 3;
  // Size is the size in bytes of the RLP encoding of the block according to Ethereum
  // rules.
  uint64 size = 4;
  // Header contain's the block's header information like its parent hash, the merkel root hash
  // and all other information the form a block.
  BlockHeader header = 5;

  // Uncles represents block produced with a valid solution but were not actually choosen
  // as the canonical block for the given height so they are mostly "forked" blocks.
  //
  // If the Block has been produced using the Proof of Stake consensus algorithm, this
  // field will actually be always empty.
  repeated BlockHeader uncles = 6;

  // TransactionTraces hold the execute trace of all the transactions that were executed
  // in this block. In in there that you will find most of the Ethereum data model.
  //
  // They are ordered by the order of execution of the transaction in the block.
  repeated TransactionTrace transaction_traces = 10;

  // BalanceChanges here is the array of ETH transfer that happened at the block level
  // outside of the normal transaction flow of a block. The best example of this is mining
  // reward for the block mined, the transfer of ETH to the miner happens outside the normal
  // transaction flow of the chain and is recorded as a `BalanceChange` here since we cannot
  // attached it to any transaction.
  //
  // Only available in DetailLevel: EXTENDED
  repeated BalanceChange balance_changes = 11;

  enum DetailLevel{
    DETAILLEVEL_EXTENDED = 0;
    // DETAILLEVEL_TRACE = 1; // TBD
    DETAILLEVEL_BASE = 2;
  }

  // DetailLevel affects the data available in this block.
  //
  // ## DetailLevel_EXTENDED
  //
  // Describes the most complete block, with traces, balance changes, storage
  // changes. It is extracted during the execution of the block.
  //
  // ## DetailLevel_BASE
  //
  // Describes a block that contains only the block header, transaction receipts
  // and event logs: everything that can be extracted using the base JSON-RPC
  // interface
  // (https://ethereum.org/en/developers/docs/apis/json-rpc/#json-rpc-methods)
  // Furthermore, the eth_getTransactionReceipt call has been avoided because it
  // brings only minimal improvements at the cost of requiring an archive node
  // or a full node with complete transaction index.
  DetailLevel detail_level = 12;

  // CodeChanges here is the array of smart code change that happened that happened at the block level
  // outside of the normal transaction flow of a block. Some Ethereum's fork like BSC and Polygon
  // has some capabilities to upgrade internal smart contracts used usually to track the validator
  // list.
  //
  // On hard fork, some procedure runs to upgrade the smart contract code to a new version. In those
  // network, a `CodeChange` for each modified smart contract on upgrade would be present here. Note
  // that this happen rarely, so the vast majority of block will have an empty list here.
  //
  // Only available in DetailLevel: EXTENDED
  repeated CodeChange code_changes = 20;

  // System calls are introduced in Cancun, along with blobs. They are executed outside of transactions but affect the state.
  //
  // Only available in DetailLevel: EXTENDED
  repeated Call system_calls = 21;

  reserved 40; // bool filtering_applied = 40 [deprecated = true];
  reserved 41; // string filtering_include_filter_expr = 41 [deprecated = true];
  reserved 42; // string filtering_exclude_filter_expr = 42 [deprecated = true];

  // Ver represents that data model version of the block, it is used internally by Firehose on Ethereum
  // as a validation that we are reading the correct version.
  int32 ver = 1;
}

message BlockHeader {
  bytes parent_hash = 1;

  // Uncle hash of the block, some reference it as `sha3Uncles`, but `sha3`` is badly worded, so we prefer `uncle_hash`, also
  // referred as `ommers` in EIP specification.
  //
  // If the Block containing this `BlockHeader` has been produced using the Proof of Stake
  // consensus algorithm, this field will actually be constant and set to `0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347`.
  bytes uncle_hash = 2;

  bytes coinbase = 3;
  bytes state_root = 4;
  bytes transactions_root = 5;
  bytes receipt_root = 6;
  bytes logs_bloom = 7;

  // Difficulty is the difficulty of the Proof of Work algorithm that was required to compute a solution.
  //
  // If the Block containing this `BlockHeader` has been produced using the Proof of Stake
  // consensus algorithm, this field will actually be constant and set to `0x00`.
  BigInt difficulty = 8;

  // TotalDifficulty is the sum of all previous blocks difficulty including this block difficulty.
  //
  // If the Block containing this `BlockHeader` has been produced using the Proof of Stake
  // consensus algorithm, this field will actually be constant and set to the terminal total difficulty
  // that was required to transition to Proof of Stake algorithm, which varies per network. It is set to
  // 58 750 000 000 000 000 000 000 on Ethereum Mainnet and to 10 790 000 on Ethereum Testnet Goerli.
  BigInt total_difficulty = 17;

  uint64 number = 9;
  uint64 gas_limit = 10;
  uint64 gas_used = 11;
  google.protobuf.Timestamp timestamp = 12;

  // ExtraData is free-form bytes included in the block by the "miner". While on Yellow paper of
  // Ethereum this value is maxed to 32 bytes, other consensus algorithm like Clique and some other
  // forks are using bigger values to carry special consensus data.
  //
  // If the Block containing this `BlockHeader` has been produced using the Proof of Stake
  // consensus algorithm, this field is strictly enforced to be <= 32 bytes.
  bytes extra_data = 13;

  // MixHash is used to prove, when combined with the `nonce` that sufficient amount of computation has been
  // achieved and that the solution found is valid.
  bytes mix_hash = 14;

  // Nonce is used to prove, when combined with the `mix_hash` that sufficient amount of computation has been
  // achieved and that the solution found is valid.
  //
  // If the Block containing this `BlockHeader` has been produced using the Proof of Stake
  // consensus algorithm, this field will actually be constant and set to `0`.
  uint64 nonce = 15;

  // Hash is the hash of the block which is actually the computation:
  //
  //  Keccak256(rlp([
  //    parent_hash,
  //    uncle_hash,
  //    coinbase,
  //    state_root,
  //    transactions_root,
  //    receipt_root,
  //    logs_bloom,
  //    difficulty,
  //    number,
  //    gas_limit,
  //    gas_used,
  //    timestamp,
  //    extra_data,
  //    mix_hash,
  //    nonce,
  //    base_fee_per_gas (to be included only if London fork is active)
  //    withdrawals_root (to be included only if Shangai fork is active)
  //    blob_gas_used (to be included only if Cancun fork is active)
  //    excess_blob_gas (to be included only if Cancun fork is active)
  //    parent_beacon_root (to be included only if Cancun fork is active)
  //  ]))
  //
  bytes hash = 16;

  // Base fee per gas according to EIP-1559 (e.g. London Fork) rules, only set if London is present/active on the chain.
  BigInt base_fee_per_gas = 18;

  // Withdrawals root hash according to EIP-4895 (e.g. Shangai Fork) rules, only set if Shangai is present/active on the chain.
  //
  // Only available in DetailLevel: EXTENDED
  bytes withdrawals_root = 19;

  // TxDependency is list of transaction indexes that are dependent on each other in the block
  // header. This is metadata only that was used by the internal Polygon parallel execution engine.
  //
  // This field was available in a few versions on Polygon Mainnet and Polygon Mumbai chains. It was actually
  // removed and is not populated anymore. It's now embeded in the `extraData` field, refer to Polygon source
  // code to determine how to extract it if you need it.
  //
  // Only available in DetailLevel: EXTENDED
  Uint64NestedArray tx_dependency = 20;

	// BlobGasUsed was added by EIP-4844 and is ignored in legacy headers.
	optional uint64 blob_gas_used = 22;

	// ExcessBlobGas was added by EIP-4844 and is ignored in legacy headers.
	optional uint64 excess_blob_gas = 23;

	// ParentBeaconRoot was added by EIP-4788 and is ignored in legacy headers.
	bytes parent_beacon_root = 24;
}

message Uint64NestedArray {
    repeated Uint64Array val = 1;
}

message Uint64Array {
    repeated uint64 val = 1;
}

message BigInt {
  bytes bytes = 1;
}

// TransactionTrace is full trace of execution of the transaction when the
// it actually executed on chain.
//
// It contains all the transaction details like `from`, `to`, `gas`, etc.
// as well as all the internal calls that were made during the transaction.
//
// The `calls` vector contains Call objects which have balance changes, events
// storage changes, etc.
//
// If ordering is important between elements, almost each message like `Log`,
// `Call`, `StorageChange`, etc. have an ordinal field that is represents "execution"
// order of the said element against all other elements in this block.
//
// Due to how the call tree works doing "naively", looping through all calls then
// through a Call's element like `logs` while not yielding the elements in the order
// they were executed on chain. A log in call could have been done before or after
// another in another call depending on the actual call tree.
//
// The `calls` are ordered by creation order and the call tree can be re-computing
// using fields found in `Call` object (parent/child relationship).
//
// Another important thing to note is that even if a transaction succeed, some calls
// within it could have been reverted internally, if this is important to you, you must
// check the field `state_reverted` on the `Call` to determine if it was fully committed
// to the chain or not.
message TransactionTrace {
  // consensus
  bytes to = 1;
  uint64 nonce = 2;
  // GasPrice represents the effective price that has been paid for each gas unit of this transaction. Over time, the
  // Ethereum rules changes regarding GasPrice field here. Before London fork, the GasPrice was always set to the
  // fixed gas price. After London fork, this value has different meaning depending on the transaction type (see `Type` field).
  //
  // In cases where `TransactionTrace.Type == TRX_TYPE_LEGACY || TRX_TYPE_ACCESS_LIST`, then GasPrice has the same meaning
  // as before the London fork.
  //
  // In cases where `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE`, then GasPrice is the effective gas price paid
  // for the transaction which is equals to `BlockHeader.BaseFeePerGas + TransactionTrace.`
  BigInt gas_price = 3;

  // GasLimit is the maximum of gas unit the sender of the transaction is willing to consume when perform the EVM
  // execution of the whole transaction
  uint64 gas_limit = 4;

  // Value is the amount of Ether transferred as part of this transaction.
  BigInt value = 5;

  // Input data the transaction will receive for execution of EVM.
  bytes input = 6;

  // V is the recovery ID value for the signature Y point.
  bytes v = 7;

  // R is the signature's X point on the elliptic curve (32 bytes).
  bytes r = 8;

  // S is the signature's Y point on the elliptic curve (32 bytes).
  bytes s = 9;

  // GasUsed is the total amount of gas unit used for the whole execution of the transaction.
  uint64 gas_used = 10;

  // Type represents the Ethereum transaction type, available only since EIP-2718 & EIP-2930 activation which happened on Berlin fork.
  // The value is always set even for transaction before Berlin fork because those before the fork are still legacy transactions.
  Type type = 12;

  enum Type {
    // All transactions that ever existed prior Berlin fork before EIP-2718 was implemented.
    TRX_TYPE_LEGACY = 0;

    // Transaction that specicy an access list of contract/storage_keys that is going to be used
    // in this transaction.
    //
    // Added in Berlin fork (EIP-2930).
    TRX_TYPE_ACCESS_LIST = 1;

    // Transaction that specifis an access list just like TRX_TYPE_ACCESS_LIST but in addition defines the
    // max base gas gee and max priority gas fee to pay for this transaction. Transaction's of those type are
    // executed against EIP-1559 rules which dictates a dynamic gas cost based on the congestion of the network.
    TRX_TYPE_DYNAMIC_FEE = 2;

    // Transaction which contain a large amount of data that cannot be accessed by EVM execution, but whose commitment
    // can be accessed. The format is intended to be fully compatible with the format that will be used in full sharding.
    //
    // Transaction that defines specifis an access list just like TRX_TYPE_ACCESS_LIST and enables dynamic fee just like
    // TRX_TYPE_DYNAMIC_FEE but in addition defines the fields 'max_fee_per_data_gas' of type 'uint256' and the fields
    // 'blob_versioned_hashes' field represents a list of hash outputs from 'kzg_to_versioned_hash'.
    //
    // Activated in Dencun
    TRX_TYPE_BLOB = 3;

    // Arbitrum-specific transactions
    TRX_TYPE_ARBITRUM_DEPOSIT = 100;
    TRX_TYPE_ARBITRUM_UNSIGNED	= 101;
    TRX_TYPE_ARBITRUM_CONTRACT = 102;
    TRX_TYPE_ARBITRUM_RETRY	= 104;
    TRX_TYPE_ARBITRUM_SUBMIT_RETRYABLE	= 105;
    TRX_TYPE_ARBITRUM_INTERNAL	= 106;
    TRX_TYPE_ARBITRUM_LEGACY	= 120;

  }

  // AcccessList represents the storage access this transaction has agreed to do in which case those storage
  // access cost less gas unit per access.
  //
  // This will is populated only if `TransactionTrace.Type == TRX_TYPE_ACCESS_LIST || TRX_TYPE_DYNAMIC_FEE` which
  // is possible only if Berlin (TRX_TYPE_ACCESS_LIST) nor London (TRX_TYPE_DYNAMIC_FEE) fork are active on the chain.
  repeated AccessTuple access_list = 14;

  // MaxFeePerGas is the maximum fee per gas the user is willing to pay for the transaction gas used.
  //
  // This will is populated only if `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE` which is possible only
  // if Londong fork is active on the chain.
  //
  // Only available in DetailLevel: EXTENDED
  BigInt max_fee_per_gas = 11;

  // MaxPriorityFeePerGas is priority fee per gas the user to pay in extra to the miner on top of the block's
  // base fee.
  //
  // This will is populated only if `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE` which is possible only
  // if London fork is active on the chain.
  //
  // Only available in DetailLevel: EXTENDED
  BigInt max_priority_fee_per_gas = 13;

  // meta
  uint32 index = 20;
  bytes hash = 21;
  bytes from = 22;
  // Only available in DetailLevel: EXTENDED
  bytes return_data = 23;
  // Only available in DetailLevel: EXTENDED
  bytes public_key = 24;

  // The block's global ordinal when the transaction started executing, refer to
  // [Block] documentation for further information about ordinals and total ordering.
  uint64 begin_ordinal = 25;

  // The block's global ordinal when the transaction finished executing, refer to
  // [Block] documentation for further information about ordinals and total ordering.
  uint64 end_ordinal = 26;

  // TransactionTraceStatus is the status of the transaction execution and will let you know if the transaction
  // was successful or not.
  //
  // ## Explanation relevant only for blocks with `DetailLevel: EXTENDED`
  //
  // A successful transaction has been recorded to the blockchain's state for calls in it that were successful.
  // This means it's possible only a subset of the calls were properly recorded, refer to [calls[].state_reverted] field
  // to determine which calls were reverted.
  //
  // A quirks of the Ethereum protocol is that a transaction `FAILED` or `REVERTED` still affects the blockchain's
  // state for **some** of the state changes. Indeed, in those cases, the transactions fees are still paid to the miner
  // which means there is a balance change for the transaction's emitter (e.g. `from`) to pay the gas fees, an optional
  // balance change for gas refunded to the transaction's emitter (e.g. `from`) and a balance change for the miner who
  // received the transaction fees. There is also a nonce change for the transaction's emitter (e.g. `from`).
  //
  // This means that to properly record the state changes for a transaction, you need to conditionally procees the
  // transaction's status.
  //
  // For a `SUCCEEDED` transaction, you iterate over the `calls` array and record the state changes for each call for
  // which `state_reverted == false` (if a transaction succeeded, the call at #0 will always `state_reverted == false`
  // because it aligns with the transaction).
  //
  // For a `FAILED` or `REVERTED` transaction, you iterate over the root call (e.g. at #0, will always exist) for
  // balance changes you process those where `reason` is either `REASON_GAS_BUY`, `REASON_GAS_REFUND` or
  // `REASON_REWARD_TRANSACTION_FEE` and for nonce change, still on the root call, you pick the nonce change which the
  // smallest ordinal (if more than one).
  TransactionTraceStatus status = 30;

  TransactionReceipt receipt = 31;

  // Only available in DetailLevel: EXTENDED
  repeated Call calls = 32;

  // BlobGas is the amount of gas the transaction is going to pay for the blobs, this is a computed value
  // equivalent to `self.blob_gas_fee_cap * len(self.blob_hashes)` and provided in the model for convenience.
  //
  // This is specified by https://eips.ethereum.org/EIPS/eip-4844
  //
  // This will is populated only if `TransactionTrace.Type == TRX_TYPE_BLOB` which is possible only
  // if Cancun fork is active on the chain.
  optional uint64 blob_gas = 33;

  // BlobGasFeeCap is the maximum fee per data gas the user is willing to pay for the data gas used.
  //
  // This is specified by https://eips.ethereum.org/EIPS/eip-4844
  //
  // This will is populated only if `TransactionTrace.Type == TRX_TYPE_BLOB` which is possible only
  // if Cancun fork is active on the chain.
  optional BigInt blob_gas_fee_cap = 34;

  // BlobHashes field represents a list of hash outputs from 'kzg_to_versioned_hash' which
  // essentially is a version byte + the sha256 hash of the blob commitment (e.g.
  // `BLOB_COMMITMENT_VERSION_KZG + sha256(commitment)[1:]`.
  //
  // This is specified by https://eips.ethereum.org/EIPS/eip-4844
  //
  // This will is populated only if `TransactionTrace.Type == TRX_TYPE_BLOB` which is possible only
  // if Cancun fork is active on the chain.
  repeated bytes blob_hashes = 35;
}

// AccessTuple represents a list of storage keys for a given contract's address and is used
// for AccessList construction.
message AccessTuple {
  bytes address = 1;
  repeated bytes storage_keys = 2;
}

enum TransactionTraceStatus {
  UNKNOWN = 0;
  SUCCEEDED = 1;
  FAILED = 2;
  REVERTED = 3;
}

message TransactionReceipt {
  // State root is an intermediate state_root hash, computed in-between transactions to make
  // **sure** you could build a proof and point to state in the middle of a block. Geth client
  // uses `PostState + root + PostStateOrStatus`` while Parity used `status_code, root...`` this piles
  // hardforks, see (read the EIPs first):
  // - https://github.com/ethereum/EIPs/blob/master/EIPS/eip-658.md
  //
  // Moreover, the notion of `Outcome`` in parity, which segregates the two concepts, which are
  // stored in the same field `status_code`` can be computed based on such a hack of the `state_root`
  // field, following `EIP-658`.
  //
  // Before Byzantinium hard fork, this field is always empty.
  bytes state_root = 1;
  uint64 cumulative_gas_used = 2;
  bytes logs_bloom = 3;
  repeated Log logs = 4;

  // BlobGasUsed is the amount of blob gas that has been used within this transaction. At time
  // of writing, this is equal to `self.blob_gas_fee_cap * len(self.blob_hashes)`.
  //
  // This is specified by https://eips.ethereum.org/EIPS/eip-4844
  //
  // This will is populated only if `TransactionTrace.Type == TRX_TYPE_BLOB` which is possible only
  // if Cancun fork is active on the chain.
  optional uint64 blob_gas_used = 5;

  // BlobGasPrice is the amount to pay per blob item in the transaction.
  //
  // This is specified by https://eips.ethereum.org/EIPS/eip-4844
  //
  // This will is populated only if `TransactionTrace.Type == TRX_TYPE_BLOB` which is possible only
  // if Cancun fork is active on the chain.
  optional BigInt blob_gas_price = 6;
}

message Log {
  bytes address = 1;
  repeated bytes topics = 2;
  bytes data = 3;

  // Index is the index of the log relative to the transaction. This index
  // is always populated regardless of the state revertion of the the call
  // that emitted this log.
  //
  // Only available in DetailLevel: EXTENDED
  uint32 index = 4;

  // BlockIndex represents the index of the log relative to the Block.
  //
  // An **important** notice is that this field will be 0 when the call
  // that emitted the log has been reverted by the chain.
  //
  // Currently, there is two locations where a Log can be obtained:
  // - block.transaction_traces[].receipt.logs[]
  // - block.transaction_traces[].calls[].logs[]
  //
  // In the `receipt` case, the logs will be populated only when the call
  // that emitted them has not been reverted by the chain and when in this
  // position, the `blockIndex` is always populated correctly.
  //
  // In the case of `calls` case, for `call` where `stateReverted == true`,
  // the `blockIndex` value will always be 0.
  uint32 blockIndex = 6;

  // The block's global ordinal when the log was recorded, refer to [Block]
  // documentation for further information about ordinals and total ordering.
  uint64 ordinal = 7;
}

message Call {
  uint32 index = 1;
  uint32 parent_index = 2;
  uint32 depth = 3;
  CallType call_type = 4;
  bytes caller = 5;
  bytes address = 6;
  BigInt value = 7;
  uint64 gas_limit = 8;
  uint64 gas_consumed = 9;
  bytes return_data = 13;
  bytes input = 14;
  bool executed_code = 15;
  bool suicide = 16;

  /* hex representation of the hash -> preimage */
  map<string, string> keccak_preimages = 20;
  repeated StorageChange storage_changes = 21;
  repeated BalanceChange balance_changes = 22;
  repeated NonceChange nonce_changes = 24;
  repeated Log logs = 25;
  repeated CodeChange code_changes = 26;

  // Deprecated: repeated bytes created_accounts
  reserved 27;

  repeated GasChange gas_changes = 28;

  // Deprecated: repeated GasEvent gas_events
  reserved 29;

  // In Ethereum, a call can be either:
  // - Successfull, execution passes without any problem encountered
  // - Failed, execution failed, and remaining gas should be consumed
  // - Reverted, execution failed, but only gas consumed so far is billed, remaining gas is refunded
  //
  // When a call is either `failed` or `reverted`, the `status_failed` field
  // below is set to `true`. If the status is `reverted`, then both `status_failed`
  // and `status_reverted` are going to be set to `true`.
  bool status_failed = 10;
  bool status_reverted = 12;

  // Populated when a call either failed or reverted, so when `status_failed == true`,
  // see above for details about those flags.
  string failure_reason = 11;

  // This field represents wheter or not the state changes performed
  // by this call were correctly recorded by the blockchain.
  //
  // On Ethereum, a transaction can record state changes even if some
  // of its inner nested calls failed. This is problematic however since
  // a call will invalidate all its state changes as well as all state
  // changes performed by its child call. This means that even if a call
  // has a status of `SUCCESS`, the chain might have reverted all the state
  // changes it performed.
  //
  // ```text
  //   Trx 1
  //    Call #1 <Failed>
  //      Call #2 <Execution Success>
  //      Call #3 <Execution Success>
  //      |--- Failure here
  //    Call #4
  // ```
  //
  // In the transaction above, while Call #2 and Call #3 would have the
  // status `EXECUTED`.
  //
  // If you check all calls and check only `state_reverted` flag, you might be missing
  // some balance changes and nonce changes. This is because when a full transaction fails
  // in ethereum (e.g. `calls.all(x.state_reverted == true)`), there is still the transaction
  // fee that are recorded to the chain.
  //
  // Refer to [TransactionTrace#status] field for more details about the handling you must
  // perform.
  bool state_reverted = 30;

  // The block's global ordinal when the call started executing, refer to
  // [Block] documentation for further information about ordinals and total ordering.
  uint64 begin_ordinal = 31;

  // The block's global ordinal when the call finished executing, refer to
  // [Block] documentation for further information about ordinals and total ordering.
  uint64 end_ordinal = 32;

  repeated AccountCreation account_creations = 33;

  reserved 50; // repeated ERC20BalanceChange erc20_balance_changes = 50 [deprecated = true];
  reserved 51; // repeated ERC20TransferEvent erc20_transfer_events = 51 [deprecated = true];
  reserved 60; // bool filtering_matched = 60 [deprecated = true];
}

enum CallType {
  UNSPECIFIED = 0;
  CALL = 1; // direct? what's the name for `Call` alone?
  CALLCODE = 2;
  DELEGATE = 3;
  STATIC = 4;
  CREATE = 5; // create2 ? any other form of calls?
}

message StorageChange {
  bytes address = 1;
  bytes key = 2;
  bytes old_value = 3;
  bytes new_value = 4;

  // The block's global ordinal when the storage change was recorded, refer to [Block]
  // documentation for further information about ordinals and total ordering.
  uint64 ordinal = 5;
}

message BalanceChange {
  bytes address = 1;
  BigInt old_value = 2;
  BigInt new_value = 3;
  Reason reason = 4;

  // Obtain all balanche change reasons under deep mind repository:
  //
  // ```shell
  // ack -ho 'BalanceChangeReason\(".*"\)' | grep -Eo '".*"' | sort | uniq
  // ```
  enum Reason {
    REASON_UNKNOWN = 0;
    REASON_REWARD_MINE_UNCLE = 1;
    REASON_REWARD_MINE_BLOCK = 2;
    REASON_DAO_REFUND_CONTRACT = 3;
    REASON_DAO_ADJUST_BALANCE = 4;
    REASON_TRANSFER = 5;
    REASON_GENESIS_BALANCE = 6;
    REASON_GAS_BUY = 7;
    REASON_REWARD_TRANSACTION_FEE = 8;
    REASON_REWARD_FEE_RESET = 14;
    REASON_GAS_REFUND = 9;
    REASON_TOUCH_ACCOUNT = 10;
    REASON_SUICIDE_REFUND = 11;
    REASON_SUICIDE_WITHDRAW = 13;
    REASON_CALL_BALANCE_OVERRIDE = 12;
    // Used on chain(s) where some Ether burning happens
    REASON_BURN = 15;
    REASON_WITHDRAWAL = 16;

    // Rewards for Blob processing on BNB chain added in Tycho hard-fork, refers
    // to BNB documentation to check the timestamp at which it was activated.
    REASON_REWARD_BLOB_FEE = 17;
  }

  // The block's global ordinal when the balance change was recorded, refer to [Block]
  // documentation for further information about ordinals and total ordering.
  uint64 ordinal = 5;
}

message NonceChange {
  bytes address = 1;
  uint64 old_value = 2;
  uint64 new_value = 3;

  // The block's global ordinal when the nonce change was recorded, refer to [Block]
  // documentation for further information about ordinals and total ordering.
  uint64 ordinal = 4;
}

message AccountCreation {
  bytes account = 1;

  // The block's global ordinal when the account creation was recorded, refer to [Block]
  // documentation for further information about ordinals and total ordering.
  uint64 ordinal = 2;
}

message CodeChange {
  bytes address = 1;
  bytes old_hash = 2;
  bytes old_code = 3;
  bytes new_hash = 4;
  bytes new_code = 5;

  // The block's global ordinal when the code change was recorded, refer to [Block]
  // documentation for further information about ordinals and total ordering.
  uint64 ordinal = 6;
}

// The gas change model represents the reason why some gas cost has occurred.
// The gas is computed per actual op codes. Doing them completely might prove
// overwhelming in most cases.
//
// Hence, we only index some of them, those that are costy like all the calls
// one, log events, return data, etc.
message GasChange {
  uint64 old_value = 1;
  uint64 new_value = 2;
  Reason reason = 3;

  // Obtain all gas change reasons under deep mind repository:
  //
  // ```shell
  // ack -ho 'GasChangeReason\(".*"\)' | grep -Eo '".*"' | sort | uniq
  // ```
  enum Reason {
    REASON_UNKNOWN = 0;
    // REASON_CALL is the amount of gas that will be charged for a 'CALL' opcode executed by the EVM
    REASON_CALL = 1;
    // REASON_CALL_CODE is the amount of gas that will be charged for a 'CALLCODE' opcode executed by the EVM
    REASON_CALL_CODE = 2;
    // REASON_CALL_DATA_COPY is the amount of gas that will be charged for a 'CALLDATACOPY' opcode executed by the EVM
    REASON_CALL_DATA_COPY = 3;
    // REASON_CODE_COPY is the amount of gas that will be charged for a 'CALLDATACOPY' opcode executed by the EVM
    REASON_CODE_COPY = 4;
    // REASON_CODE_STORAGE is the amount of gas that will be charged for code storage
    REASON_CODE_STORAGE = 5;
    // REASON_CONTRACT_CREATION is the amount of gas that will be charged for a 'CREATE' opcode executed by the EVM and for the gas
    // burned for a CREATE, today controlled by EIP150 rules
    REASON_CONTRACT_CREATION = 6;
    // REASON_CONTRACT_CREATION2 is the amount of gas that will be charged for a 'CREATE2' opcode executed by the EVM and for the gas
    // burned for a CREATE2, today controlled by EIP150 rules
    REASON_CONTRACT_CREATION2 = 7;
    // REASON_DELEGATE_CALL is the amount of gas that will be charged for a 'DELEGATECALL' opcode executed by the EVM
    REASON_DELEGATE_CALL = 8;
    // REASON_EVENT_LOG is the amount of gas that will be charged for a 'LOG<N>' opcode executed by the EVM
    REASON_EVENT_LOG = 9;
    // REASON_EXT_CODE_COPY is the amount of gas that will be charged for a 'LOG<N>' opcode executed by the EVM
    REASON_EXT_CODE_COPY = 10;
    // REASON_FAILED_EXECUTION is the burning of the remaining gas when the execution failed without a revert
    REASON_FAILED_EXECUTION = 11;
    // REASON_INTRINSIC_GAS is the amount of gas that will be charged for the intrinsic cost of the transaction, there is
    // always exactly one of those per transaction
    REASON_INTRINSIC_GAS = 12;
    // GasChangePrecompiledContract is the amount of gas that will be charged for a precompiled contract execution
    REASON_PRECOMPILED_CONTRACT = 13;
    // REASON_REFUND_AFTER_EXECUTION is the amount of gas that will be refunded to the caller after the execution of the call,
    // if there is left over at the end of execution
    REASON_REFUND_AFTER_EXECUTION = 14;
    // REASON_RETURN is the amount of gas that will be charged for a 'RETURN' opcode executed by the EVM
    REASON_RETURN = 15;
    // REASON_RETURN_DATA_COPY is the amount of gas that will be charged for a 'RETURNDATACOPY' opcode executed by the EVM
    REASON_RETURN_DATA_COPY = 16;
    // REASON_REVERT is the amount of gas that will be charged for a 'REVERT' opcode executed by the EVM
    REASON_REVERT = 17;
    // REASON_SELF_DESTRUCT is the amount of gas that will be charged for a 'SELFDESTRUCT' opcode executed by the EVM
    REASON_SELF_DESTRUCT = 18;
    // REASON_STATIC_CALL is the amount of gas that will be charged for a 'STATICALL' opcode executed by the EVM
    REASON_STATIC_CALL = 19;

    // REASON_STATE_COLD_ACCESS is the amount of gas that will be charged for a cold storage access as controlled by EIP2929 rules
    //
    // Added in Berlin fork (Geth 1.10+)
    REASON_STATE_COLD_ACCESS = 20;

    // REASON_TX_INITIAL_BALANCE is the initial balance for the call which will be equal to the gasLimit of the call
    //
    // Added as new tracing reason in Geth, available only on some chains
    REASON_TX_INITIAL_BALANCE = 21;
    // REASON_TX_REFUNDS is the sum of all refunds which happened during the tx execution (e.g. storage slot being cleared)
	  // this generates an increase in gas. There is only one such gas change per transaction.
    //
    // Added as new tracing reason in Geth, available only on some chains
    REASON_TX_REFUNDS = 22;
    // REASON_TX_LEFT_OVER_RETURNED is the amount of gas left over at the end of transaction's execution that will be returned
    // to the chain. This change will always be a negative change as we "drain" left over gas towards 0. If there was no gas
    // left at the end of execution, no such even will be emitted. The returned gas's value in Wei is returned to caller.
    // There is at most one of such gas change per transaction.
    //
    // Added as new tracing reason in Geth, available only on some chains
    REASON_TX_LEFT_OVER_RETURNED = 23;

    // REASON_CALL_INITIAL_BALANCE is the initial balance for the call which will be equal to the gasLimit of the call. There is only
	  // one such gas change per call.
    //
    // Added as new tracing reason in Geth, available only on some chains
    REASON_CALL_INITIAL_BALANCE = 24;
    // REASON_CALL_LEFT_OVER_RETURNED is the amount of gas left over that will be returned to the caller, this change will always
    // be a negative change as we "drain" left over gas towards 0. If there was no gas left at the end of execution, no such even
    // will be emitted.
    REASON_CALL_LEFT_OVER_RETURNED = 25;
  }

  // The block's global ordinal when the gas change was recorded, refer to [Block]
  // documentation for further information about ordinals and total ordering.
  uint64 ordinal = 4;
}

// HeaderOnlyBlock is used to optimally unpack the [Block] structure (note the
// corresponding message number for the `header` field) while consuming less
// memory, when only the `header` is desired.
//
// WARN: this is a client-side optimization pattern and should be moved in the
// consuming code.
message HeaderOnlyBlock {
  BlockHeader header = 5;
}

// BlockWithRefs is a lightweight block, with traces and transactions
// purged from the `block` within, and only.  It is used in transports
// to pass block data around.
message BlockWithRefs {
  string id = 1;
  Block block = 2;
  TransactionRefs transaction_trace_refs = 3;
  bool irreversible = 4;
}

message TransactionTraceWithBlockRef {
  TransactionTrace trace = 1;
  BlockRef block_ref = 2;
}

message TransactionRefs {
  repeated bytes hashes = 1;
}

message BlockRef {
  bytes hash = 1;
  uint64 number = 2;
}
